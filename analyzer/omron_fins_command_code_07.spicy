module OMRON_FINS_COMMAND_CODE_07;

import spicy;
import OMRON_FINS_ENUMS;
import OMRON_FINS_FUNCTIONS;
import OMRON_FINS_TYPES;

#
# ClockRead
#
type ClockRead = unit(dataType: OMRON_FINS_ENUMS::DataType) {
    switch(dataType) {
        OMRON_FINS_ENUMS::DataType::COMMAND  -> command : ClockRead_Command();
        OMRON_FINS_ENUMS::DataType::RESPONSE -> response: ClockRead_Response();
    };
};

type ClockRead_Command = unit {
    : bytes &eod; # Note: There is no data associated with the ClockRead command - hence the anonymous field
};

type ClockRead_Response = unit {
    responseCode : uint16 &convert=OMRON_FINS_ENUMS::ResponseCode($$);
    year         : uint8;
    month        : uint8;
    date         : uint8;
    hour         : uint8;
    minute       : uint8;
    second       : uint8;
    day          : uint8 &convert=OMRON_FINS_ENUMS::DayOfWeek($$);
};

#
# ClockWrite
#
type ClockWrite = unit(dataType: OMRON_FINS_ENUMS::DataType) {
    switch(dataType) {
        OMRON_FINS_ENUMS::DataType::COMMAND  -> command : ClockWrite_Command();
        OMRON_FINS_ENUMS::DataType::RESPONSE -> response: ClockWrite_Response();
    };
};

type ClockWrite_Command = unit {
    year         : uint8;
    month        : uint8;
    date         : uint8;
    hour         : uint8;
    minute       : uint8;
    data         : bytes &eod;
    var second   : uint8;
    var day      : OMRON_FINS_ENUMS::DayOfWeek;
    on %done {
        #
        # The second and day parameters are optional and are parsed as bytes to the &eod.  Once
        # parsed, then length is checked to determine if one or both fields need to be set.
        #
        if ( |self.data| == 1 ) {
            self.second = *self.data.at(0);
        } 
        
        if ( |self.data| == 2) {
            self.second = *self.data.at(0);
            self.day = OMRON_FINS_ENUMS::DayOfWeek(*self.data.at(1));
        }
    }
};

type ClockWrite_Response = unit {
    responseCode : uint16 &convert=OMRON_FINS_ENUMS::ResponseCode($$);
};
